package views

import (
	"github.com/sprungknoedl/dagobert/app/model"
	"github.com/sprungknoedl/dagobert/pkg/fp"
	"github.com/sprungknoedl/dagobert/pkg/valid"
	"strings"
	"time"
)

templ EventsMany(env Env, rows []model.Event, assets []model.Asset, indicators []model.Indicator) {
	@layout() {
		@list(env, "Timeline", navHideImport(), navPreButtons(eventsManyExtra(env))) {
			<div id="histogram" class="card bg-base-200 text-xs m-4 p-4"></div>
			<!-- -->
			<table class="table table-default" data-default-sort="value-0">
				<thead>
					<tr>
						<th data-sort="value-0" class="sort px-3 py-4 text-left">Time</th>
						<th data-sort="value-1" class="sort px-3 py-4 text-left">Type</th>
						<th data-sort="value-2" class="sort px-3 py-4 text-left">Event</th>
						<th data-sort="value-3" class="sort px-3 py-4 text-left">Assets</th>
						<th data-sort="value-4" class="sort px-3 py-4 text-left">Indicators</th>
						<th style="width: 7rem"></th>
					</tr>
				</thead>
				<tbody class="values">
					for _, row := range rows {
						<tr class={ fp.If(row.Flagged, "hover bg-flagged", "hover") }>
							<td class="value-0" data-search={ row.Time.Format(time.RFC3339) }>
								@formatTime(row.Time)
							</td>
							<td class="value-1" data-search={ row.Type }>
								@enum(env.Enums.EventTypes, row.Type)
							</td>
							<td class="fixed-width value-2" data-search={ row.Event }>
								<details>
									<summary>
										@highlightEvent(row, assets, indicators)
									</summary>
									if row.Raw != "" {
										<div class="card bg-base-200 rounded-box gap-2 mt-4 p-4 overflow-scroll">
											<p class="font-bold">Raw:</p>
											<pre><code>{ row.Raw }</code></pre>
										</div>
									}
								</details>
							</td>
							<td class="value-3" data-search={ strings.Join(fp.Apply(row.Assets, func(x model.Asset) string { return x.Name }), " ") }>
								for _, x := range row.Assets {
									<div class="text-info">
										@enumIcon(env.Enums.AssetTypes, x.Type) {
											{ x.Name }
										}
									</div>
								}
							</td>
							<td class="value-4" data-search={ strings.Join(fp.Apply(row.Indicators, func(x model.Indicator) string { return x.Value }), " ") }>
								for _, x := range row.Indicators {
									<div class="text-error">
										@enumIcon(env.Enums.IndicatorTypes, x.Type) {
											{ x.Value }
										}
									</div>
								}
							</td>
							<td class="text-right" data-search={ fp.If(row.Flagged, "flagged:true", "") }>
								<div class="join">
									if row.Flagged {
										@actionBtn(env, "GET", env.Route+row.ID) {
											<i class="hio hio-5 hio-flag btn-flagged"></i>
										}
									}
									@defaultActionBtns(env, env.Route+row.ID)
								</div>
							</td>
						</tr>
					}
				</tbody>
			</table>
			// histogram
			<script src="/public/assets/vis-graph2d-7.7.4.min.js"></script>
			<script>
			function initializeChart(items) {
				var options = {
					style: "bar",
					barChart: { align: "center" },
					dataAxis: { visible: false },
					drawPoints: false,
					height: "150px",
					orientation: "bottom",
					// showMinorLabels: false,
					moment: (date) => vis.moment(date).utc(),

				};

				var container = document.getElementById("histogram");
				var timeline = new vis.Graph2d(container, new vis.DataSet(items), options);
			}
			</script>
			@templ.JSFuncCall("initializeChart", histogram(rows, 50))
		}
	}
}

templ EventsOne(env Env, obj model.Event, assets []model.Asset, indicators []model.Indicator, vr valid.Result) {
	{{ uri := "/cases/" + obj.CaseID + "/events/" + obj.ID }}
	{{ title := fp.If(obj.ID == "new", "Add event", "Edit event") }}
	@form(uri, title) {
		@hiddenField("ID", obj.ID)
		@hiddenField("CaseID", obj.CaseID)
		<div class="form-control mb-2">
			<label class="label justify-start gap-2">
				Time
				@requiredLabel()
				@validationError(vr["Time"])
			</label>
			<div class="join w-full">
				<input name="Time" type="text" class="join-item input w-full" value={ obj.Time.Format("2006-01-02T15:04:05Z07:00") }/>
				<a class="join-item btn" onclick="setNow()">Now</a>
			</div>
		</div>
		@selectField("Type", obj.Type, env.Enums.EventTypes, required(), withLabel("Type"), withError(vr["Type"]))
		@textareaField("Event", obj.Event, required(), withLabel("Event"), withError(vr["Event"]))
		@textareaField("Raw", obj.Raw, withLabel("Raw"), withError(vr["Raw"]))
		@booleanField("Flagged", obj.Flagged, withLabel("Flagged"))
		@choicesField("Assets", withLabel("Assets"), withError(vr["Assets"])) {
			for _, x := range assets {
				<option value={ x.Name } selected?={ obj.HasAsset(x.ID) }>{ x.Name }</option>
			}
		}
		@choicesField("Indicators", withLabel("Indicators"), withError(vr["Indicators"])) {
			for _, x := range indicators {
				<option value={ x.Value } selected?={ obj.HasIndicator(x.ID) }>{ x.Value }</option>
			}
		}
		<p class="text-sm">Fields marked with <span class="text-neutral">*</span> are required.</p>
		<script>
		function setNow() {
			let now = new Date(Date.now()).toISOString();
			document.querySelector('input[name="Time"]').value = now;
		}
		</script>
	}
}

func highlightEvent(ev model.Event, assets []model.Asset, indicators []model.Indicator) templ.Component {
	html := templ.EscapeString(ev.Event)
	// first highlight linked indicators, then any
	for _, x := range ev.Indicators {
		html = strings.ReplaceAll(html, x.Value, "<span class='text-error'>"+templ.EscapeString(x.Value)+"</span>")
	}
	for _, x := range indicators {
		html = strings.ReplaceAll(html, x.Value, "<span class='text-error'>"+templ.EscapeString(x.Value)+"</span>")
	}

	// first highlight linked assets, then any
	for _, x := range ev.Assets {
		html = strings.ReplaceAll(html, x.Name, "<span class='text-info'>"+templ.EscapeString(x.Name)+"</span>")
		if x.Addr != "" {
			html = strings.ReplaceAll(html, x.Addr, "<span class='text-info'>"+templ.EscapeString(x.Addr)+"</span>")
		}
	}
	for _, x := range assets {
		html = strings.ReplaceAll(html, x.Name, "<span class='text-info'>"+templ.EscapeString(x.Name)+"</span>")
		if x.Addr != "" {
			html = strings.ReplaceAll(html, x.Addr, "<span class='text-info'>"+templ.EscapeString(x.Addr)+"</span>")
		}
	}

	return templ.Raw(html)
}

templ eventsManyExtra(env Env) {
	if url, ok := env.Allowed("POST", env.Route+"import"); ok {
		<details class="dropdown">
			<summary class="btn join-item">
				<i class="hio hio-6 hio-bars-arrow-up inline-block mr-1"></i> Import
			</summary>
			<ul style="position: absolute" class="menu dropdown-content bg-base-200 rounded-box z-[1] w-52 p-2 shadow">
				<li><a href={ url + "/csv" } up-layer="new drawer" up-accept-location={ env.Route }>from CSV</a></li>
				<li><a href={ url + "/timesketch" } up-follow up-method="post">from Timesketch</a></li>
			</ul>
		</details>
	}
}

type TimeHistogram map[time.Time]int
type HistogramItem struct {
	X   string `json:"x"`
	End string `json:"end"`
	Y   int    `json:"y"`
}

// histogram creates a histogram with a fixed number of buckets.
func histogram(events []model.Event, numBuckets int) []HistogramItem {
	if len(events) < 2 || numBuckets <= 0 {
		// Not enough data or invalid bucket count.
		return []HistogramItem{}
	}

	// Find the min and max times to determine the range.
	minTime, maxTime := time.Time(events[0].Time), time.Time(events[0].Time)
	for _, e := range events {
		if time.Time(e.Time).Before(minTime) {
			minTime = time.Time(e.Time)
		}
		if time.Time(e.Time).After(maxTime) {
			maxTime = time.Time(e.Time)
		}
	}

	duration := maxTime.Sub(minTime)
	if duration <= 0 {
		return []HistogramItem{}
	}

	// Calculate the size of each bucket.
	bucketSize := time.Duration(int64(duration) / int64(numBuckets))
	if bucketSize < 1 {
		bucketSize = 1
	}

	histogram := make(TimeHistogram)
	for _, event := range events {
		bucket := time.Time(event.Time).Truncate(bucketSize)
		histogram[bucket]++
	}

	dataset := []HistogramItem{}
	for x, y := range histogram {
		dataset = append(dataset, HistogramItem{
			X:   x.Format(time.RFC3339),
			End: x.Add(bucketSize).Format(time.RFC3339),
			Y:   y,
		})
	}
	return dataset
}
