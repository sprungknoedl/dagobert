package views

import (
	_ "embed"
	"github.com/sprungknoedl/dagobert/app/assets"
	"github.com/sprungknoedl/dagobert/app/model"
	"regexp"
	"strconv"
	"strings"
)

type Node struct {
	ID    string `json:"id"`
	Label string `json:"label"`
	Group string `json:"group"`
}

type Edge struct {
	From   string `json:"from"`
	To     string `json:"to"`
	Dashes bool   `json:"dashes"`
}

type icon struct {
	Code  string `json:"code"`
	Size  int    `json:"size"`
	Color string `json:"color"`
}

type group struct {
	Icon icon `json:"icon"`
}

var iconMap = parseHeroiconsCSS(assets.HeroiconsCSS)

templ VisNetwork(env Env, nodes []Node, edges []Edge) {
	@layout() {
		<section id="errors"></section>
		@sidebar(env, "Lateral Movement")
		<main class="pl-20 p-4 grow max-w-full flex flex-col h-screen">
			@navbar(env, "Lateral Movement", navHideRefresh(), navHideAdd(), navHideImport(), navHideExport())
			<div id="mynetwork" class="h-full"></div>
		</main>
		<script src="/public/assets/vis-network-9.1.9.min.js"></script>
		<script>
        function initializeChart(nodes, edges, groups) {
            const options = {
                edges: {
                    color: {
                        color: "oklch(85% 0.199 91.936)",
                        highlight: "oklch(75% 0.183 55.934)",
                    },
                    smooth: {
                        forceDirection: "vertical"
                    }
                },
                nodes: {
                    shape: "icon",
                    margin: 10,
                    font: {
                        color: "oklch(20% 0 0)",
                        background: "oklch(100% 0 0)",
                    },
                    icon: {
                        face: "'heroicons-outline'",
                    },
                },
                groups: groups,
                "physics": {
                    "repulsion": {
                        "centralGravity": 0.25,
                        "springLength": 150,
                        "nodeDistance": 175,
                        "damping": 0.15
                    },
                    "minVelocity": 0.75,
                    "solver": "repulsion"
                }
            };

            // create a network
            var container = document.getElementById("mynetwork");
            var data = {
                nodes: new vis.DataSet(nodes),
                edges: new vis.DataSet(edges),
            };

            var network = new vis.Network(container, data, options);
        }
        </script>
		@templ.JSFuncCall("initializeChart", nodes, edges, networkGroups(env.Enums.AssetTypes, env.Enums.IndicatorTypes))
	}
}

func networkGroups(assets []model.Enum, indicators []model.Enum) map[string]group {
	groups := map[string]group{}
	for _, enum := range assets {
		groups["Asset"+enum.Name] = group{
			Icon: icon{
				Code:  string(iconMap[enum.Icon]),
				Color: "oklch(37% 0.01 67.558)",
				Size:  50,
			},
		}
	}

	for _, enum := range indicators {
		groups["Indicator"+enum.Name] = group{
			Icon: icon{
				Code:  string(iconMap[enum.Icon]),
				Color: "oklch(70% 0.191 22.216)",
				Size:  32,
			},
		}
	}

	return groups
}

// ParseHeroiconsCSS parses the CSS content and returns a map of icon class to unicode symbol.
// It works on the whole file and supports multi-line icon definitions.
func parseHeroiconsCSS(css string) map[string]rune {
	iconMap := make(map[string]rune)
	// Regex matches .hio-xxx:before { ... content: "\e900"; ... }
	re := regexp.MustCompile(`\.([a-zA-Z0-9\-]+):before\s*\{[^}]*content:\s*"(\\e[0-9a-fA-F]{3,4})";`)
	matches := re.FindAllStringSubmatch(css, -1)
	for _, m := range matches {
		if len(m) == 3 {
			hex := strings.TrimPrefix(m[2], "\\")
			code, _ := strconv.ParseInt(hex, 16, 32)
			iconMap[m[1]] = rune(code)
		}
	}

	return iconMap
}
