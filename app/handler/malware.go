package handler

import (
	"database/sql"
	"encoding/csv"
	"fmt"
	"net/http"
	"time"

	"github.com/sprungknoedl/dagobert/app/model"
	"github.com/sprungknoedl/dagobert/app/views"
	"github.com/sprungknoedl/dagobert/pkg/fp"
	"github.com/sprungknoedl/dagobert/pkg/valid"
	"gorm.io/gorm"
)

type MalwareCtrl struct {
	Ctrl
}

func NewMalwareCtrl(store *model.Store, acl *ACL) *MalwareCtrl {
	return &MalwareCtrl{BaseCtrl{store, acl}}
}

func (ctrl MalwareCtrl) List(w http.ResponseWriter, r *http.Request) {
	cid := r.PathValue("cid")
	list, err := ctrl.Store().ListMalware(cid)
	if err != nil {
		Err(w, r, err)
		return
	}

	Render(w, r, http.StatusOK, views.MalwareMany(Env(ctrl, r), list))
}

func (ctrl MalwareCtrl) Export(w http.ResponseWriter, r *http.Request) {
	cid := r.PathValue("cid")
	list, err := ctrl.Store().ListMalware(cid)
	if err != nil {
		Err(w, r, err)
		return
	}

	kase := GetCase(ctrl.Store(), r)
	filename := fmt.Sprintf("%s - %s - Malware.csv", time.Now().Format("20060102"), kase.Name)
	w.Header().Set("Content-Disposition", "attachment; filename=\""+filename+"\"")
	w.WriteHeader(http.StatusOK)

	cw := csv.NewWriter(w)
	cw.Write([]string{"ID", "Status", "Path", "Hash", "Source", "Notes"})
	for _, e := range list {
		cw.Write([]string{
			e.ID,
			e.Status,
			e.Path,
			e.Hash,
			e.Asset.Name,
			e.Notes,
		})
	}

	cw.Flush()
	Err(w, r, err)
}

func (ctrl MalwareCtrl) Import(w http.ResponseWriter, r *http.Request) {
	cid := r.PathValue("cid")
	uri := fmt.Sprintf("/cases/%s/malware/", cid)
	ImportCSV(ctrl.Store(), ctrl.ACL(), w, r, uri, 6, func(rec []string) {
		// import asset (creates new one if they don't exist)
		asset, err := ctrl.Store().GetAssetByName(cid, rec[4])
		if err != nil && err != sql.ErrNoRows {
			Err(w, r, fmt.Errorf("get asset by name: %w", err))
			return
		} else if err != nil && err == sql.ErrNoRows {
			asset = model.Asset{
				ID:     fp.Random(10),
				Name:   rec[5],
				Status: "Under investigation",
				Type:   "Other",
			}
			err = ctrl.Store().SaveAsset(cid, asset)
			if err != nil {
				Err(w, r, fmt.Errorf("save asset: %w", err))
				return
			}
		}

		obj := model.Malware{
			ID:     fp.If(rec[0] == "", fp.Random(10), rec[0]),
			Status: rec[1],
			Path:   rec[2],
			Hash:   rec[3],
			Asset:  asset,
			Notes:  rec[5],
			CaseID: cid,
		}

		if err := ctrl.Store().SaveMalware(cid, obj); err != nil {
			Err(w, r, err)
			return
		}
	})
}

func (ctrl MalwareCtrl) Edit(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	cid := r.PathValue("cid")
	obj := model.Malware{ID: id, CaseID: cid}
	if id != "new" {
		var err error
		obj, err = ctrl.Store().GetMalware(cid, id)
		if err != nil {
			Err(w, r, err)
			return
		}
	}

	assets, err := ctrl.Store().ListAssets(cid)
	if err != nil {
		Err(w, r, err)
		return
	}

	Render(w, r, http.StatusOK, views.MalwareOne(Env(ctrl, r), obj, assets, valid.Result{}))
}

func (ctrl MalwareCtrl) Save(w http.ResponseWriter, r *http.Request) {
	dto := model.Malware{ID: r.PathValue("id"), CaseID: r.PathValue("cid")}
	if err := Decode(r, &dto); err != nil {
		Warn(w, r, err)
		return
	}

	// special case: push indicators
	tmp := struct {
		PushPathIOC bool
		PushHashIOC bool
	}{}
	if err := Decode(r, &tmp); err != nil {
		Warn(w, r, err)
		return
	}

	enums, err := ctrl.Store().ListEnums()
	if err != nil {
		Err(w, r, err)
		return
	}

	if vr := ValidateMalware(dto, enums); !vr.Valid() {
		assets, err := ctrl.Store().ListAssets(dto.CaseID)
		if err != nil {
			Err(w, r, err)
			return
		}

		Render(w, r, http.StatusUnprocessableEntity, views.MalwareOne(Env(ctrl, r), dto, assets, vr))
		return
	}

	// kind of: validate asset exists
	asset, err := ctrl.Store().GetAsset(dto.CaseID, dto.Asset.ID)
	if err != nil {
		Warn(w, r, fmt.Errorf("unknown asset: %w", err))
		return
	}

	new := dto.ID == "new"
	dto.ID = fp.If(new, fp.Random(10), dto.ID)
	if err := ctrl.Store().SaveMalware(dto.CaseID, dto); err != nil {
		Err(w, r, err)
		return
	}

	if tmp.PushPathIOC && dto.Path != "" {
		_, err := ctrl.Store().GetIndicatorByValue(dto.CaseID, dto.Path)
		if err != nil && err != gorm.ErrRecordNotFound {
			Err(w, r, fmt.Errorf("get indicator by value: %w", err))
			return
		} else if err != nil && err == gorm.ErrRecordNotFound {
			obj := model.Indicator{
				ID:     fp.Random(10),
				CaseID: dto.CaseID,
				Value:  dto.Path,
				Source: asset.Name,
				Status: "Confirmed",
				Type:   "Path",
				TLP:    "TLP:RED",
			}
			if err := ctrl.Store().SaveIndicator(dto.CaseID, obj, false); err != nil {
				Err(w, r, fmt.Errorf("save indicator: %w", err))
				return
			}
		}
	}

	if tmp.PushHashIOC && dto.Hash != "" {
		_, err := ctrl.Store().GetIndicatorByValue(dto.CaseID, dto.Hash)
		if err != nil && err != gorm.ErrRecordNotFound {
			Err(w, r, fmt.Errorf("get indicator by value: %w", err))
			return
		} else if err != nil && err == gorm.ErrRecordNotFound {
			obj := model.Indicator{
				ID:     fp.Random(10),
				CaseID: dto.CaseID,
				Value:  dto.Hash,
				Source: asset.Name,
				Status: "Confirmed",
				Type:   "Hash",
				TLP:    "TLP:RED",
			}
			if err := ctrl.Store().SaveIndicator(dto.CaseID, obj, false); err != nil {
				Err(w, r, fmt.Errorf("save indicator: %w", err))
				return
			}
		}
	}

	http.Redirect(w, r, fmt.Sprintf("/cases/%s/malware/", dto.CaseID), http.StatusSeeOther)
}

func (ctrl MalwareCtrl) Delete(w http.ResponseWriter, r *http.Request) {
	id := r.PathValue("id")
	cid := r.PathValue("cid")
	if r.URL.Query().Get("confirm") != "yes" {
		uri := fmt.Sprintf("/cases/%s/malware/%s?confirm=yes", cid, id)
		Render(w, r, http.StatusOK, views.ConfirmDialog(uri))
		return
	}

	err := ctrl.Store().DeleteMalware(cid, id)
	if err != nil {
		Err(w, r, err)
		return
	}

	http.Redirect(w, r, fmt.Sprintf("/cases/%s/malware/", cid), http.StatusSeeOther)
}
