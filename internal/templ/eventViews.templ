package templ

import (
	"fmt"
	"math"
	"time"
	"strings"

	"github.com/sprungknoedl/dagobert/internal/templ/utils"
	"github.com/sprungknoedl/dagobert/pkg/model"
	"github.com/sprungknoedl/dagobert/pkg/valid"
	"hash/adler32"
)

type EventDTO struct {
	ID        string
	CaseID    string
	Time      string `form:"time"`
	Type      string `form:"type"`
	AssetA    string `form:"assetA"`
	AssetB    string `form:"assetB"`
	Direction string `form:"direction"`
	Event     string `form:"event"`
	Raw       string `form:"raw"`
	KeyEvent  bool   `form:"keyevent"`
}

templ EventForm(env utils.Env, obj EventDTO, assets []string, vr valid.Result) {
	@utils.Modal("max-w-4xl") {
		<form hx-post={env.Routes("save-event", obj.CaseID, obj.ID)} hx-target="#modal">
		@utils.ModalHeader() {
			if obj.ID == ZeroID {
				Add event
			} else {
				Edit event
			}
		}

		@utils.ModalBody() {
			@utils.TextInput("Date / Time", "time", obj.Time, true, vr["Time"])
			@utils.SelectInput("Type", "type", obj.Type, model.EventTypes, true, vr["Type"])
			@utils.SelectInput("Event System", "assetA", obj.AssetA, assets, true, vr["Event System"])
			@utils.SelectInput("Direction", "direction", obj.Direction, model.EventDirections, false, vr["Direction"])
			@utils.SelectInput("Remote System", "assetB", obj.AssetB, optional(assets), false, vr["Remote System"])
			@utils.TextareaInput("Event", "event", obj.Event, true, vr["Event"])
			@utils.TextareaInput("Raw", "raw", obj.Raw, false, vr["Raw"])
			@utils.BooleanInput("Key Event", "keyevent", obj.KeyEvent, vr["Key Event"])
		}

		@utils.DefaultCrudFooter() {}
		</form>
	}
}

templ EventList(env utils.Env, cid string, list []model.Event, indicators []model.Indicator) {
	@TableView(env, "Timeline", CrudUrls{
		List: env.Routes("list-events", cid),
		Import: env.Routes("import-events", cid),
		Export: env.Routes("export-events", cid),
		Add: env.Routes("view-event", cid, ZeroID),
	}) {
		@utils.TableHead() {
			@utils.TH(env, "time", templ.Attributes{"style": "width: 20rem"}) { Date / Time  }
			@utils.TH(env, "type", templ.Attributes{"style": "width: 15rem"}) { Type  }
			@utils.TH(env, "src", templ.Attributes{"style": "width: 15rem"}) { Event System  }
			@utils.TH(env, "dst", templ.Attributes{"style": "width: 15rem"}) { Remote System  }
			@utils.TH(env, "event", templ.Attributes{"style": "width: auto"})  { Event  }
			@utils.TH(env, "", templ.Attributes{"style": "width: 7rem"})  { }
		}

		@utils.TableBody() {
			for i, obj := range list {
			if b, d := hasTimeGap(list, i); b {
				<tr>
					<td class="text-center p-8" colspan="6">
					<span class="badge badge-accent badge-lg p-4">Mind the gap: { d }</span>
					</td>
				</tr>
			}

			@utils.TR(nil) {
				@utils.TD() { @renderTime(obj.Time) }
				@utils.TD() { @renderEventType(obj.Type) }
				@utils.TD() {{ obj.AssetA }}
				@utils.TD() {{ obj.Direction + " " + obj.AssetB }}
				@utils.TD() { @highlightIndicators(obj.Event, indicators) }
				@utils.DefaultTableButtons(env.Routes("view-event", cid, obj.ID), env.Routes("delete-event", cid, obj.ID)) {}
			}}
		}

		if len(list) == 0 {
			@utils.EmptyCaption(env.Routes("view-event", cid, ZeroID)) {}
		}
	}
}

templ renderTime(t time.Time) {
	{ t.Format("2006-01-02 15:04:05.000") } <span class="text-neutral">{ t.Format("Z07:00") }</span>
}

templ renderEventType(typ string) {
	<span class="flex items-center gap-2 text-sm font-medium me-3">
		<span class={"badge " + toColor(typ)}></span> {typ}
	</span>
}

var colors = []string{
	"bg-cyan-500",
	"bg-fuchsia-500",
	"bg-green-500",
	"bg-indigo-500",
	"bg-red-500",
	"bg-slate-500",
	"bg-yellow-500",
}

func toColor(typ string) string {
	i := int(adler32.Checksum([]byte(typ))) % len(colors)
	return colors[i]
}

func hasTimeGap(list []model.Event, i int) (bool, string) {
	if i > 0 {
		prev := list[i-1].Time
		curr := list[i].Time
		if d := curr.Sub(prev); d > 2 * 24 * time.Hour {
			return true, humanizeDuration(d)
		}
	}

	return false, ""
}

func humanizeDuration(duration time.Duration) string {
	days := int64(duration.Hours() / 24)
	hours := int64(math.Mod(duration.Hours(), 24))
	minutes := int64(math.Mod(duration.Minutes(), 60))
	seconds := int64(math.Mod(duration.Seconds(), 60))

	chunks := []struct {
		singularName string
		amount	   int64
	}{
		{"day", days},
		{"hour", hours},
		{"minute", minutes},
		{"second", seconds},
	}

	parts := []string{}

	for _, chunk := range chunks {
		switch chunk.amount {
		case 0:
			continue
		case 1:
			parts = append(parts, fmt.Sprintf("%d %s", chunk.amount, chunk.singularName))
		default:
			parts = append(parts, fmt.Sprintf("%d %ss", chunk.amount, chunk.singularName))
		}
	}

	return strings.Join(parts, " ")
}

func highlightIndicators(event string, indicators []model.Indicator) templ.Component {
	event = templ.EscapeString(event)
	for _, ioc := range indicators {
		event = strings.ReplaceAll(event, ioc.Value, "<span title=\"Indicator: " + templ.EscapeString(ioc.Description) + "\" class=\"text-primary underline\">" + templ.EscapeString(ioc.Value) + "</span>")
	}
	return templ.Raw(event)
}

func optional(slice []string) []string {
	return append([]string{""}, slice...)
}
