package model

import (
	"database/sql"
	"encoding/json"
	"time"
)

type Malware struct {
	ID       string
	Filename string
	Filepath string
	CDate    time.Time
	MDate    time.Time
	Hash     string
	Notes    string
	CaseID   string
	RawAsset []byte

	Asset Asset
}

func (store *Store) FindMalware(cid string, search string, sort string) ([]Malware, error) {
	query := `
	SELECT 
		m.id, m.filename, m.filepath, m.c_date, m.m_date, m.hash, m.notes, m.case_id,
		json_object('ID', a.id, 'Type', a.type, 'Name', a.name)
	FROM malware m
	LEFT JOIN
		assets a ON m.asset_id = a.id
	WHERE m.case_id = :cid AND (
		instr(m.filename, :search) > 0 OR
		instr(m.filepath, :search) > 0 OR
		instr(a.name, :search) > 0 OR
		instr(m.hash, :search) > 0 OR
		instr(m.notes, :search) > 0)
	ORDER BY
		CASE WHEN :sort = 'notes'     THEN m.notes END ASC,
		CASE WHEN :sort = '-notes'    THEN m.notes END DESC,
		CASE WHEN :sort = 'hash'      THEN m.hash END ASC,
		CASE WHEN :sort = '-hash'     THEN m.hash END DESC,
		CASE WHEN :sort = 'system'    THEN a.name END ASC,
		CASE WHEN :sort = '-system'   THEN a.name END DESC,
		CASE WHEN :sort = 'cdate'     THEN m.c_date END ASC,
		CASE WHEN :sort = '-cdate'    THEN m.c_date END DESC,
		CASE WHEN :sort = 'mdate'     THEN m.m_date END ASC,
		CASE WHEN :sort = '-mdate'    THEN m.m_date END DESC,
		CASE WHEN :sort = 'filepath'  THEN m.filepath END ASC,
		CASE WHEN :sort = '-filepath' THEN m.filepath END DESC,
		CASE WHEN :sort = '-filename' THEN m.filename END DESC,
		m.filename ASC`

	rows, err := store.db.Query(query,
		sql.Named("cid", cid),
		sql.Named("search", search),
		sql.Named("sort", sort))
	if err != nil {
		return nil, err
	}

	var list []Malware
	err = ScanAll(rows, &list)

	// unmarshal json encoded relations
	for i, elem := range list {
		err = json.Unmarshal(elem.RawAsset, &elem.Asset)
		if err != nil {
			return nil, err
		}

		list[i] = elem
	}

	return list, err
}

func (store *Store) GetMalware(cid string, id string) (Malware, error) {
	query := `
	SELECT 
		m.id, m.filename, m.filepath, m.c_date, m.m_date, m.hash, m.notes, m.case_id,
		json_object('ID', a.id, 'Type', a.type, 'Name', a.name)
	FROM malware m
	LEFT JOIN
		assets a ON m.asset_id = a.id
	WHERE m.case_id = :cid AND m.id = :id
	LIMIT 1`

	rows, err := store.db.Query(query,
		sql.Named("cid", cid),
		sql.Named("id", id))
	if err != nil {
		return Malware{}, err
	}

	var obj Malware
	err = ScanOne(rows, &obj)
	if err != nil {
		return Malware{}, err
	}

	// unmarshal json encoded relations
	err = json.Unmarshal(obj.RawAsset, &obj.Asset)
	if err != nil {
		return Malware{}, err
	}

	return obj, err
}

func (store *Store) SaveMalware(cid string, obj Malware) error {
	query := `
	REPLACE INTO malware (id, filename, filepath, c_date, m_date, hash, notes, case_id, asset_id)
	VALUES (NULLIF(:id, ''), :filename, :filepath, :cdate, :mdate, :hash, :notes, :cid, :asset)`

	_, err := store.db.Exec(query,
		sql.Named("cid", cid),
		sql.Named("id", obj.ID),
		sql.Named("filename", obj.Filename),
		sql.Named("filepath", obj.Filepath),
		sql.Named("cdate", obj.CDate),
		sql.Named("mdate", obj.MDate),
		sql.Named("asset", obj.Asset.ID),
		sql.Named("hash", obj.Hash),
		sql.Named("notes", obj.Notes))
	return err
}

func (store *Store) DeleteMalware(cid string, id string) error {
	query := `
	DELETE FROM malware
	WHERE id = :id`

	_, err := store.db.Exec(query,
		sql.Named("id", id))
	return err
}
